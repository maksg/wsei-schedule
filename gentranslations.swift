#!/usr/bin/env xcrun --sdk macosx swift

import Foundation

struct LocalizationGroup {
    let name: String
    var path: String
    var stringArrays: [[String]]
    var subgroups: [LocalizationGroup]
    
    var containsLocalizationString: Bool {
        var contains = false
        subgroups.forEach { group in
            if group.subgroups.isEmpty {
                contains = true
            }
        }
        return contains
    }
}

extension Array where Element == LocalizationGroup {
    subscript(name: String) -> LocalizationGroup {
        get {
            return first(where: { $0.name == name }) ?? LocalizationGroup(name: name, path: "", stringArrays: [], subgroups: [])
        }
        set {
            if let index = firstIndex(where: { $0.name == name }) {
                self[index] = newValue
            } else {
                append(newValue)
            }
        }
    }
}

extension String {
    
    var camelCased: String {
        let parts = self.lowercased().components(separatedBy: "_")
        let firstPart = parts.first ?? ""
        let capitalizedParts = parts.dropFirst().map({ $0.capitalized }).joined()
        return firstPart + capitalizedParts
    }
    
    var capitalizeFirst: String {
        return prefix(1).uppercased() + dropFirst()
    }
    
    var asKeyword: String {
        return "`\(self)`"
    }
    
}

extension Date {
    
    var short: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter.string(from: self)
    }
    
}

class GenTranslations {
    
    private let fileManager = FileManager.default
    private var regularExpresions = [String : NSRegularExpression]()
    
    private let keywords: [String] = ["final", "class", "let", "var", "enum", "func", "case", "guard",
                                      "if", "else", "do", "catch", "return", "struct", "extension",
                                      "get", "set", "where", "self", "default", "nil", "throws", "try"]
    private let localizableStringsRegex = "\".*\"?"
    private let keywordRegex = "^\"([^\"]*)\""
    private let tab = "   "
    
    private enum GenstringsError: Error {
        case Error
    }
    
    // Perform the gentranslations functionality
    func perform(path: String? = nil) {
        guard let fileURL = getLocalizableFileURL(path: path) else { return }
        
        let localizableStrings = localizableStringsInFile(fileURL)
        let keywordStrings = keywords(fromLocalizableStrings: localizableStrings)
        let stringArrays = keywordStrings.map({ $0.components(separatedBy: ".") })
        let container = localizationGroups(fromStringArrays: stringArrays)
        printTranslations(from: container)
    }
    
    private func getLocalizableFileURL(path: String?) -> URL? {
        let url: URL?
        if let path = path {
            url = URL(fileURLWithPath: path)
        } else {
            let rootPath = URL(fileURLWithPath: fileManager.currentDirectoryPath)
            url = fetchFileURLInFolder(rootPath: rootPath)
        }
        return url
    }
    
    private func printTranslations(from container: [LocalizationGroup]) {
        var containerString = """
        //
        //  Generated by gentranslations.swift
        //\n\n
        """
        if container.contains(where: { $0.path.isEmpty && $0.subgroups.isEmpty }) {
            containerString.append("enum Translation: String {\n")
        } else {
            containerString.append("enum Translation {\n")
        }
        containerString.append(generateContainer(container))
        containerString.append("\n}")
        containerString = containerString.replacingOccurrences(of: "\n\n\n", with: "\n\n")
        print(containerString)
    }
    
    func generateContainer(_ container: [LocalizationGroup], indentationLevel: Int = 1) -> String {
        var containerString: String = ""
        container.forEach { group in
            let indentation = [String](repeating: tab, count: indentationLevel).joined()
            let groupName = group.name.camelCased
            
            if group.subgroups.isEmpty {
                let name = makeKeyword(groupName)
                let content = group.path.isEmpty ? group.name : "\(group.path).\(group.name)"
                containerString.append("\(indentation)case \(name) = \"\(content)\"\n")
            } else {
                let name = makeKeyword(groupName.capitalizeFirst)
                
                containerString.append("\n")
                if group.containsLocalizationString {
                    containerString.append("\(indentation)enum \(name): String {\n")
                } else {
                    containerString.append("\(indentation)enum \(name) {\n")
                }
                containerString.append(generateContainer(group.subgroups, indentationLevel: indentationLevel+1))
                containerString.append("\(indentation)}\n")
                containerString.append("\n")
            }
        }
        return containerString
    }
    
    private func makeKeyword(_ text: String) -> String {
        return keywords.contains(text) ? text.asKeyword : text
    }
    
    func localizationGroups(fromStringArrays stringArrays: [[String]], withPath path: String = "") -> [LocalizationGroup] {
        var container = [LocalizationGroup]()
        for array in stringArrays where !array.isEmpty {
            let name = array.first ?? ""
            container[name].stringArrays += [Array(array.dropFirst())]
        }
        for group in container {
            container[group.name].path = path
            let subpath = path.isEmpty ? group.name : "\(path).\(group.name)"
            container[group.name].subgroups = localizationGroups(fromStringArrays: group.stringArrays, withPath: subpath)
        }
        return container
    }
    
    func keywords(fromLocalizableStrings localizableStrings: Set<String>) -> [String] {
        let convertedStrings = localizableStrings.compactMap { string -> String? in
            do {
                let array = try regexMatches(pattern: keywordRegex, string: string)
                return Set(array).first
            } catch {
                print(error)
                return nil
            }
        }
        
        return Set(convertedStrings).map({ $0.replacingOccurrences(of: "\"", with: "") }).sorted(by: { $0 < $1 })
    }
    
    // Applies regex to a file at filePath.
    
    func localizableStringsInFile(_ url: URL) -> Set<String> {
        do {
            let fileContentsData = try Data(contentsOf: url)
            guard let fileContentsString = String(data: fileContentsData, encoding: .utf8) else { return Set<String>() }
            let regexMatchesArray = try regexMatches(pattern: localizableStringsRegex, string: fileContentsString as String)
            return Set(regexMatchesArray)
        } catch {
            print(error)
        }
        
        return Set<String>()
    }
    
    // MARK: - Regex
    
    func regexWithPattern(pattern: String) throws -> NSRegularExpression {
        var safeRegex = regularExpresions
        if let regex = safeRegex[pattern] {
            return regex
        } else {
            do {
                let currentPattern = try NSRegularExpression(pattern: pattern, options: .caseInsensitive)
                safeRegex.updateValue(currentPattern, forKey: pattern)
                regularExpresions = safeRegex
                return currentPattern
            }
            catch {
                print(error)
                throw GenstringsError.Error
            }
        }
    }
    
    func regexMatches(pattern: String, string: String) throws -> [String] {
        do {
            let currentPattern = try regexWithPattern(pattern: pattern)
            let range = NSMakeRange(0, string.count)
            let results = currentPattern.matches(in: string, options: [], range: range)
            let matches = results.map({ (string as NSString).substring(with: $0.range) })
            return matches
        }
        catch {
            print(error)
            throw GenstringsError.Error
        }
    }
    
    // MARK: - File manager
    
    func fetchFileURLInFolder(rootPath: URL) -> URL? {
        do {
            let directoryContents = try fileManager.contentsOfDirectory(at: rootPath as URL, includingPropertiesForKeys: [], options: .skipsHiddenFiles)
            
            for urlPath in directoryContents {
                let stringPath = urlPath.path
                var isDir: ObjCBool = false
                
                guard fileManager.fileExists(atPath: stringPath, isDirectory: &isDir) else { continue }
                if isDir.boolValue, let fileURL = fetchFileURLInFolder(rootPath: urlPath) {
                    return fileURL
                } else if stringPath.contains("en.lproj/Localizable.strings") {
                    return urlPath
                }
            }
        } catch {
            print(error)
        }
        
        return nil
    }
    
}

// MARK: -

let genTranslations = GenTranslations()
if CommandLine.arguments.count > 1 {
    let path = CommandLine.arguments[1]
    genTranslations.perform(path: path)
} else {
    genTranslations.perform()
}
